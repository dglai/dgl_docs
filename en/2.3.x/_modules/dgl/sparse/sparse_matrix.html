<!DOCTYPE html>

<html class="writer-html5" data-content_root="../../../" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>dgl.sparse.sparse_matrix — DGL 2.3.1 documentation</title>
<link href="../../../_static/pygments.css?v=80d5e7a1" rel="stylesheet" type="text/css"/>
<link href="../../../_static/css/theme.css?v=19f00094" rel="stylesheet" type="text/css"/>
<link href="../../../_static/graphviz.css?v=fd3f3429" rel="stylesheet" type="text/css"/>
<link href="../../../_static/copybutton.css?v=76b2166b" rel="stylesheet" type="text/css"/>
<link href="../../../_static/sg_gallery.css?v=d2d258e8" rel="stylesheet" type="text/css"/>
<link href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" rel="stylesheet" type="text/css"/>
<link href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" rel="stylesheet" type="text/css"/>
<link href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" rel="stylesheet" type="text/css"/>
<link href="../../../_static/css/custom.css?v=0bf289b5" rel="stylesheet" type="text/css"/>
<!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
<script src="../../../_static/jquery.js?v=5d32c60e"></script>
<script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
<script src="../../../_static/documentation_options.js?v=67b02a41"></script>
<script src="../../../_static/doctools.js?v=9a2dae69"></script>
<script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
<script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
<script src="../../../_static/copybutton.js?v=ccdb6887"></script>
<script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
<script src="../../../_static/js/theme.js"></script>
<link href="../../../genindex.html" rel="index" title="Index"/>
<link href="../../../search.html" rel="search" title="Search"/>
</head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../../index.html">
            DGL
          </a>
<div class="version">
                2.3.1
              </div>
<div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div><div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<p class="caption" role="heading"><span class="caption-text">Get Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html">Install and Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/blitz/index.html">A Blitz Introduction to DGL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced Materials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../stochastic_training/index.html">🆕 Stochastic Training of GNNs with GraphBolt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide_cn/index.html">用户指南【包含过时信息】</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide_ko/index.html">사용자 가이드[시대에 뒤쳐진]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graphtransformer/index.html">🆕 Tutorial: Graph Transformer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/sparse/index.html">Tutorials: dgl.sparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/cpu/index.html">Training on CPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/multi/index.html">Training on Multiple GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/dist/index.html">Distributed training</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/models/index.html">Paper Study with DGL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.html">dgl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.data.html">dgl.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.dataloading.html">dgl.dataloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.DGLGraph.html">dgl.DGLGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.distributed.html">dgl.distributed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.function.html">dgl.function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.geometry.html">dgl.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.graphbolt.html">🆕 dgl.graphbolt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/nn-pytorch.html">dgl.nn (PyTorch)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/nn.functional.html">dgl.nn.functional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.ops.html">dgl.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.optim.html">dgl.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.sampling.html">dgl.sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.sparse_v0.html">dgl.sparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.multiprocessing.html">dgl.multiprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/transforms.html">dgl.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/udf.html">User-defined Functions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contribute to DGL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/ffi.html">DGL Foreign Function Interface (FFI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../performance.html">Performance Benchmarks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Misc</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">Frequently Asked Questions (FAQ)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../env_var.html">Environment Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resources.html">Resources</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="Mobile navigation menu" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../../index.html">DGL</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="Page navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Home" class="icon icon-home" href="../../../index.html"></a></li>
<li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
<li class="breadcrumb-item active">dgl.sparse.sparse_matrix</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<h1>Source code for dgl.sparse.sparse_matrix</h1><div class="highlight"><pre>
<span></span><span class="sd">"""DGL sparse matrix module."""</span>
<span class="c1"># pylint: disable= invalid-name</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">torch</span>


<div class="viewcode-block" id="SparseMatrix">
<a class="viewcode-back" href="../../../api/python/dgl.sparse_v0.html#dgl.sparse.SparseMatrix">[docs]</a>
<span class="k">class</span> <span class="nc">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""Class for sparse matrix."""</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c_sparse_matrix</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">ScriptObject</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span> <span class="o">=</span> <span class="n">c_sparse_matrix</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_sparse_matrix_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">val</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Returns the values of the non-zero elements.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Values of the non-zero elements</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">val</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">"""Returns the shape of the sparse matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[int]</span>
<span class="sd">            The shape of the sparse matrix</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Returns the number of non-zero elements in the sparse matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of non-zero elements of the matrix</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">nnz</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Returns the data type of the sparse matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.dtype</span>
<span class="sd">            Data type of the sparse matrix</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">val</span><span class="p">()</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Returns the device the sparse matrix is on.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.device</span>
<span class="sd">            The device the sparse matrix is on</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">device</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">row</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Returns the row indices of the non-zero elements.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Row indices of the non-zero elements</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coo</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">col</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Returns the column indices of the non-zero elements.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Column indices of the non-zero elements</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coo</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="SparseMatrix.coo">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.coo.html#dgl.sparse.SparseMatrix.coo">[docs]</a>
    <span class="k">def</span> <span class="nf">coo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Returns the coordinate list (COO) representation of the sparse</span>
<span class="sd">        matrix.</span>

<span class="sd">        See `COO in Wikipedia &lt;https://en.wikipedia.org/wiki/</span>
<span class="sd">        Sparse_matrix#Coordinate_list_(COO)&gt;`_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Row coordinate</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Column coordinate</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 2, 1], [2, 4, 3]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices)</span>
<span class="sd">        &gt;&gt;&gt; A.coo()</span>
<span class="sd">        (tensor([1, 2, 1]), tensor([2, 4, 3]))</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">coo</span><span class="p">()</span></div>


<div class="viewcode-block" id="SparseMatrix.indices">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.indices.html#dgl.sparse.SparseMatrix.indices">[docs]</a>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Returns the coordinate list (COO) representation in one tensor with</span>
<span class="sd">        shape ``(2, nnz)``.</span>

<span class="sd">        See `COO in Wikipedia &lt;https://en.wikipedia.org/wiki/</span>
<span class="sd">        Sparse_matrix#Coordinate_list_(COO)&gt;`_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Stacked COO tensor with shape ``(2, nnz)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 2, 1], [2, 4, 3]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices)</span>
<span class="sd">        &gt;&gt;&gt; A.indices()</span>
<span class="sd">        tensor([[1, 2, 1],</span>
<span class="sd">                [2, 4, 3]])</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span></div>


<div class="viewcode-block" id="SparseMatrix.csr">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.csr.html#dgl.sparse.SparseMatrix.csr">[docs]</a>
    <span class="k">def</span> <span class="nf">csr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Returns the compressed sparse row (CSR) representation of the sparse</span>
<span class="sd">        matrix.</span>

<span class="sd">        See `CSR in Wikipedia &lt;https://en.wikipedia.org/wiki/</span>
<span class="sd">        Sparse_matrix#Compressed_sparse_row_(CSR, _CRS_or_Yale_format)&gt;`_.</span>

<span class="sd">        This function also returns value indices as an index tensor, indicating</span>
<span class="sd">        the order of the values of non-zero elements in the CSR representation.</span>
<span class="sd">        A ``None`` value indices array indicates the order of the values stays</span>
<span class="sd">        the same as the values of the SparseMatrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Row indptr</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Column indices</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Value indices</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 2, 1], [2, 4, 3]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices)</span>
<span class="sd">        &gt;&gt;&gt; A.csr()</span>
<span class="sd">        (tensor([0, 0, 2, 3]), tensor([2, 3, 4]), tensor([0, 2, 1]))</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">csr</span><span class="p">()</span></div>


<div class="viewcode-block" id="SparseMatrix.csc">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.csc.html#dgl.sparse.SparseMatrix.csc">[docs]</a>
    <span class="k">def</span> <span class="nf">csc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Returns the compressed sparse column (CSC) representation of the</span>
<span class="sd">        sparse matrix.</span>

<span class="sd">        See `CSC in Wikipedia &lt;https://en.wikipedia.org/wiki/</span>
<span class="sd">        Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS)&gt;`_.</span>

<span class="sd">        This function also returns value indices as an index tensor, indicating</span>
<span class="sd">        the order of the values of non-zero elements in the CSC representation.</span>
<span class="sd">        A ``None`` value indices array indicates the order of the values stays</span>
<span class="sd">        the same as the values of the SparseMatrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Column indptr</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Row indices</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Value indices</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 2, 1], [2, 4, 3]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices)</span>
<span class="sd">        &gt;&gt;&gt; A.csc()</span>
<span class="sd">        (tensor([0, 0, 0, 1, 2, 3]), tensor([1, 1, 2]), tensor([0, 2, 1]))</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">csc</span><span class="p">()</span></div>


<div class="viewcode-block" id="SparseMatrix.to_dense">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.to_dense.html#dgl.sparse.SparseMatrix.to_dense">[docs]</a>
    <span class="k">def</span> <span class="nf">to_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Returns a copy in dense matrix format of the sparse matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            The copy in dense matrix format</span>
<span class="sd">        """</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coo</span><span class="p">()</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">mat</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">mat</span></div>


<div class="viewcode-block" id="SparseMatrix.t">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.t.html#dgl.sparse.SparseMatrix.t">[docs]</a>
    <span class="k">def</span> <span class="nf">t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Alias of :meth:`transpose()`"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pylint: disable=C0103</span>
<span class="w">        </span><span class="sd">"""Alias of :meth:`transpose()`"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

<div class="viewcode-block" id="SparseMatrix.transpose">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.transpose.html#dgl.sparse.SparseMatrix.transpose">[docs]</a>
    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Returns the transpose of this sparse matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The transpose of this sparse matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 3], [2, 1, 3]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.tensor([1, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">        &gt;&gt;&gt; A = A.transpose()</span>
<span class="sd">        SparseMatrix(indices=tensor([[2, 1, 3],</span>
<span class="sd">                                     [1, 1, 3]]),</span>
<span class="sd">                     values=tensor([1, 1, 2]),</span>
<span class="sd">                     shape=(4, 4), nnz=3)</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span></div>


<div class="viewcode-block" id="SparseMatrix.to">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.to.html#dgl.sparse.SparseMatrix.to">[docs]</a>
    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Performs matrix dtype and/or device conversion. If the target device</span>
<span class="sd">        and dtype are already in use, the original matrix will be returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        device : torch.device, optional</span>
<span class="sd">            The target device of the matrix if provided, otherwise the current</span>
<span class="sd">            device will be used</span>
<span class="sd">        dtype : torch.dtype, optional</span>
<span class="sd">            The target data type of the matrix values if provided, otherwise the</span>
<span class="sd">            current data type will be used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The converted matrix</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A.to(device="cuda:0", dtype=torch.int32)</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]], device='cuda:0'),</span>
<span class="sd">                     values=tensor([1, 1, 1], device='cuda:0',</span>
<span class="sd">                                   dtype=torch.int32),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

        <span class="k">if</span> <span class="n">device</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">device</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">val_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO(#5119): Find a better moving strategy instead of always</span>
            <span class="c1"># convert to COO format.</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coo</span><span class="p">()</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">from_coo</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.cuda">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.cuda.html#dgl.sparse.SparseMatrix.cuda">[docs]</a>
    <span class="k">def</span> <span class="nf">cuda</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Moves the matrix to GPU. If the matrix is already on GPU, the</span>
<span class="sd">        original matrix will be returned. If multiple GPU devices exist,</span>
<span class="sd">        ``cuda:0`` will be selected.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The matrix on GPU</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A.cuda()</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]], device='cuda:0'),</span>
<span class="sd">                     values=tensor([1., 1., 1.], device='cuda:0'),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="s2">"cuda"</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.cpu">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.cpu.html#dgl.sparse.SparseMatrix.cpu">[docs]</a>
    <span class="k">def</span> <span class="nf">cpu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Moves the matrix to CPU. If the matrix is already on CPU, the</span>
<span class="sd">        original matrix will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The matrix on CPU</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]]).to("cuda")</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(3, 4))</span>

<span class="sd">        &gt;&gt;&gt; A.cpu()</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]]),</span>
<span class="sd">                     values=tensor([1., 1., 1.]),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="s2">"cpu"</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.float">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.float.html#dgl.sparse.SparseMatrix.float">[docs]</a>
    <span class="k">def</span> <span class="nf">float</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Converts the matrix values to float32 data type. If the matrix</span>
<span class="sd">        already uses float data type, the original matrix will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The matrix with float values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.ones(len(row)).long()</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val, shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A.float()</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]]),</span>
<span class="sd">                     values=tensor([1., 1., 1.]),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.double">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.double.html#dgl.sparse.SparseMatrix.double">[docs]</a>
    <span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Converts the matrix values to double data type. If the matrix already</span>
<span class="sd">        uses double data type, the original matrix will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The matrix with double values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A.double()</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]]),</span>
<span class="sd">                     values=tensor([1., 1., 1.], dtype=torch.float64),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.int">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.int.html#dgl.sparse.SparseMatrix.int">[docs]</a>
    <span class="k">def</span> <span class="nf">int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Converts the matrix values to int32 data type. If the matrix already</span>
<span class="sd">        uses int data type, the original matrix will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DiagMatrix</span>
<span class="sd">            The matrix with int values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A.int()</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]]),</span>
<span class="sd">                     values=tensor([1, 1, 1], dtype=torch.int32),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.long">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.long.html#dgl.sparse.SparseMatrix.long">[docs]</a>
    <span class="k">def</span> <span class="nf">long</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Converts the matrix values to long data type. If the matrix already</span>
<span class="sd">        uses long data type, the original matrix will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DiagMatrix</span>
<span class="sd">            The matrix with long values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A.long()</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]]),</span>
<span class="sd">                     values=tensor([1, 1, 1]),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.coalesce">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.coalesce.html#dgl.sparse.SparseMatrix.coalesce">[docs]</a>
    <span class="k">def</span> <span class="nf">coalesce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Returns a coalesced sparse matrix.</span>

<span class="sd">        A coalesced sparse matrix satisfies the following properties:</span>

<span class="sd">          - the indices of the non-zero elements are unique,</span>
<span class="sd">          - the indices are sorted in lexicographical order.</span>

<span class="sd">        The coalescing process will accumulate the non-zero elements of the same</span>
<span class="sd">        indices by summation.</span>

<span class="sd">        The function does not support autograd.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The coalesced sparse matrix</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 0, 0, 0, 1], [1, 1, 1, 2, 2]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.tensor([0, 1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">        &gt;&gt;&gt; A.coalesce()</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 0, 1, 1],</span>
<span class="sd">                                     [1, 2, 1, 2]]),</span>
<span class="sd">                     values=tensor([3, 3, 0, 4]),</span>
<span class="sd">                     shape=(2, 3), nnz=4)</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">coalesce</span><span class="p">())</span></div>


<div class="viewcode-block" id="SparseMatrix.has_duplicate">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.has_duplicate.html#dgl.sparse.SparseMatrix.has_duplicate">[docs]</a>
    <span class="k">def</span> <span class="nf">has_duplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Returns ``True`` if the sparse matrix contains duplicate indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 0, 0, 0, 1], [1, 1, 1, 2, 2]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.tensor([0, 1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">        &gt;&gt;&gt; A.has_duplicate()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; A.coalesce().has_duplicate()</span>
<span class="sd">        False</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">has_duplicate</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">is_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Returns whether the sparse matrix is a diagonal matrix."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">is_diag</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">index_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Returns a sub-matrix selected according to the given index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            The dim to select from matrix, should be 0 or 1. `dim = 0` for</span>
<span class="sd">            rowwise selection and `dim = 1` for columnwise selection.</span>
<span class="sd">        index : torch.Tensor</span>
<span class="sd">            The selection index indicates which IDs from the `dim` should</span>
<span class="sd">            be chosen from the matrix.</span>
<span class="sd">            Note that duplicated ids are allowed.</span>

<span class="sd">        The function does not support autograd.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The sub-matrix which contains selected rows or columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([0, 1, 1, 2, 3, 4], [0, 2, 4, 3, 5, 0]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.tensor([0, 1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>

<span class="sd">        Case 1: Select rows by IDs.</span>

<span class="sd">        &gt;&gt;&gt; row_ids = torch.tensor([0, 1, 4])</span>
<span class="sd">        &gt;&gt;&gt; A.index_select(0, row_ids)</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 1, 1, 2],</span>
<span class="sd">                                     [0, 2, 4, 0]]),</span>
<span class="sd">                     values=tensor([0, 1, 2, 5]),</span>
<span class="sd">                     shape=(3, 6), nnz=4)</span>

<span class="sd">        Case 2: Select columns by IDs.</span>

<span class="sd">        &gt;&gt;&gt; column_ids = torch.tensor([0, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; A.index_select(1, column_ids)</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 4, 1, 3],</span>
<span class="sd">                                     [0, 0, 1, 2]]),</span>
<span class="sd">                     values=tensor([0, 5, 2, 4]),</span>
<span class="sd">                     shape=(5, 3), nnz=4)</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The selection dimension should be 0 or 1."</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is unsupported input type."</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">range_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">slice</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Returns a sub-matrix selected according to the given range index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            The dim to select from matrix, should be 0 or 1. `dim = 0` for</span>
<span class="sd">            rowwise selection and `dim = 1` for columnwise selection.</span>
<span class="sd">        index : slice</span>
<span class="sd">            The selection slice indicates ID index from the `dim` should</span>
<span class="sd">            be chosen from the matrix.</span>

<span class="sd">        The function does not support autograd.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The sub-matrix which contains selected rows or columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([0, 1, 1, 2, 3, 4], [0, 2, 4, 3, 5, 0]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.tensor([0, 1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>

<span class="sd">        Case 1: Select rows with given slice object.</span>

<span class="sd">        &gt;&gt;&gt; A.range_select(0, slice(1, 3))</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 0, 1],</span>
<span class="sd">                                     [2, 4, 3]]),</span>
<span class="sd">                     values=tensor([1, 2, 3]),</span>
<span class="sd">                     shape=(2, 6), nnz=3)</span>

<span class="sd">        Case 2: Select columns with given slice object.</span>

<span class="sd">        &gt;&gt;&gt; A.range_select(1, slice(3, 6))</span>
<span class="sd">        SparseMatrix(indices=tensor([[2, 1, 3],</span>
<span class="sd">                                     [0, 1, 2]]),</span>
<span class="sd">                     values=tensor([3, 2, 4]),</span>
<span class="sd">                     shape=(5, 3), nnz=3)</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The selection dimension should be 0 or 1."</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">"Slice with step other than 1 are not supported yet."</span>
                <span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span>
            <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">range_select</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is unsupported input type."</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">fanout</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">replace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">"""Returns a sampled matrix on the given dimension and sample arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            The dimension for sampling, should be 0 or 1. `dim = 0` for</span>
<span class="sd">            rowwise selection and `dim = 1` for columnwise selection.</span>
<span class="sd">        fanout : int</span>
<span class="sd">            The number of elements to randomly sample on each row or column.</span>
<span class="sd">        ids : torch.Tensor, optional</span>
<span class="sd">            An optional tensor containing row or column IDs from which to</span>
<span class="sd">            sample elements.</span>
<span class="sd">            NOTE: If `ids` is not provided (i.e., `ids = None`), the function</span>
<span class="sd">            will sample from all rows or columns.</span>
<span class="sd">        replace : bool, optional</span>
<span class="sd">            Indicates whether repeated sampling of the same element is allowed.</span>
<span class="sd">            When `replace = True`, repeated sampling is permitted; when</span>
<span class="sd">            `replace = False`, it is not allowed.</span>
<span class="sd">            NOTE: If `replace = False` and there are fewer elements than</span>
<span class="sd">            `fanout`, all non-zero elements will be sampled.</span>
<span class="sd">        bias : bool, optional</span>
<span class="sd">            A boolean flag indicating whether to enable biasing during sampling.</span>
<span class="sd">            When `bias = True`, the values of the sparse matrix will be used as</span>
<span class="sd">            bias weights.</span>

<span class="sd">        The function does not support autograd.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            A submatrix with the same shape as the original matrix, containing</span>
<span class="sd">            the randomly sampled non-zero elements.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[0, 0, 1, 1, 2, 2, 2],</span>
<span class="sd">                                    [0, 2, 0, 1, 0, 1, 2]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.tensor([0, 1, 2, 3, 4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>

<span class="sd">        Case 1: Sample rows with the given number and disable repeated sampling.</span>

<span class="sd">        &gt;&gt;&gt; row_ids = torch.tensor([0, 2])</span>
<span class="sd">        &gt;&gt;&gt; A.sample(0, 2, row_ids)</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 0, 1, 1],</span>
<span class="sd">                                     [0, 2, 0, 2]]),</span>
<span class="sd">                     values=tensor([0, 1, 4, 6]),</span>
<span class="sd">                     shape=(2, 3), nnz=4)</span>

<span class="sd">        Case 2: Sample cols with the given number and disable repeated sampling.</span>

<span class="sd">        &gt;&gt;&gt; col_ids = torch.tensor([0, 2])</span>
<span class="sd">        &gt;&gt;&gt; A.sample(1, 2, col_ids)</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 1, 0, 2],</span>
<span class="sd">                                     [0, 0, 1, 1]]),</span>
<span class="sd">                     values=tensor([0, 2, 1, 6]),</span>
<span class="sd">                     shape=(3, 2), nnz=4)</span>

<span class="sd">        Case 3: Sample rows with the given number and enable repeated sampling.</span>

<span class="sd">        &gt;&gt;&gt; row_ids = torch.tensor([0, 1])</span>
<span class="sd">        &gt;&gt;&gt; A.sample(0, 2, row_ids, True)</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 0, 1, 1],</span>
<span class="sd">                                     [0, 2, 0, 0]]),</span>
<span class="sd">                     values=tensor([0, 1, 2, 2]),</span>
<span class="sd">                     shape=(2, 3), nnz=3)</span>

<span class="sd">        Case 4: Sample cols with the given number and enable repeated sampling.</span>

<span class="sd">        &gt;&gt;&gt; col_ids = torch.tensor([0, 1])</span>
<span class="sd">        &gt;&gt;&gt; A.sample(1, 2, col_ids, True)</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 1, 1, 1],</span>
<span class="sd">                                     [0, 0, 1, 1]]),</span>
<span class="sd">                     values=tensor([0, 2, 3, 3]),</span>
<span class="sd">                     shape=(3, 2), nnz=3)</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">range</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="n">dim_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">fanout</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">replace</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compact</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">leading_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">"""Compact sparse matrix by removing rows or columns without non-zero</span>
<span class="sd">        elements in the sparse matrix and relabeling indices of the dimension.</span>

<span class="sd">        This function serves a dual purpose: it allows you to reorganize the</span>
<span class="sd">        indices within a specific dimension (rows or columns) of the sparse</span>
<span class="sd">        matrix and, if needed, place certain 'leading_indices' at the beginning</span>
<span class="sd">        of the relabeled dimension.</span>

<span class="sd">        In the absence of 'leading_indices' (when it's set to `None`), the order</span>
<span class="sd">        of relabeled indices remains the same as the original order, except that</span>
<span class="sd">        rows or columns without non-zero elements are removed. When</span>
<span class="sd">        'leading_indices' are provided, they are positioned at the start of the</span>
<span class="sd">        relabeled dimension. To be precise, all rows selected by the specified</span>
<span class="sd">        indices will be remapped from 0 to length(indices) - 1. Rows that are not</span>
<span class="sd">        selected and contain any non-zero elements will be positioned after those</span>
<span class="sd">        remapped rows while maintaining their original order.</span>

<span class="sd">        This function mimics 'dgl.to_block', a method used to compress a sampled</span>
<span class="sd">        subgraph by eliminating redundant nodes. The 'leading_indices' parameter</span>
<span class="sd">        replicates the behavior of 'include_dst_in_src' in 'dgl.to_block',</span>
<span class="sd">        adding destination node information for message passing.</span>
<span class="sd">        Setting 'leading_indices' to column IDs when relabeling the row</span>
<span class="sd">        dimension, for example, achieves the same effect as including destination</span>
<span class="sd">        nodes in source nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            The dimension to relabel. Should be 0 or 1. Use `dim = 0` for rowwise</span>
<span class="sd">            relabeling and `dim = 1` for columnwise relabeling.</span>
<span class="sd">        leading_indices : torch.Tensor, optional</span>
<span class="sd">            An optional tensor containing row or column ids that should be placed</span>
<span class="sd">            at the beginning of the relabeled dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[SparseMatrix, torch.Tensor]</span>
<span class="sd">            A tuple containing the relabeled sparse matrix and the index mapping</span>
<span class="sd">            of the relabeled dimension from the new index to the original index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[0, 2],</span>
<span class="sd">                                    [1, 2]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices)</span>
<span class="sd">        &gt;&gt;&gt; print(A.to_dense())</span>
<span class="sd">        tensor([[0., 1., 0.],</span>
<span class="sd">                [0., 0., 0.],</span>
<span class="sd">                [0., 0., 1.]])</span>

<span class="sd">        Case 1: Compact rows without indices.</span>

<span class="sd">        &gt;&gt;&gt; B, original_rows = A.compact(dim=0, leading_indices=None)</span>
<span class="sd">        &gt;&gt;&gt; print(B.to_dense())</span>
<span class="sd">        tensor([[0., 1., 0.],</span>
<span class="sd">                [0., 0., 1.]])</span>
<span class="sd">        &gt;&gt;&gt; print(original_rows)</span>
<span class="sd">        torch.Tensor([0, 2])</span>

<span class="sd">        Case 2: Compact rows with indices.</span>

<span class="sd">        &gt;&gt;&gt; B, original_rows = A.compact(dim=0, leading_indices=[1, 2])</span>
<span class="sd">        &gt;&gt;&gt; print(B.to_dense())</span>
<span class="sd">        tensor([[0., 0., 0.],</span>
<span class="sd">                [0., 0., 1.],</span>
<span class="sd">                [0., 1., 0.],])</span>
<span class="sd">        &gt;&gt;&gt; print(original_rows)</span>
<span class="sd">        torch.Tensor([1, 2, 0])</span>
<span class="sd">        """</span>
        <span class="n">mat</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">dgl_sparse</span><span class="o">.</span><span class="n">compact</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">leading_indices</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span> <span class="n">idx</span></div>



<div class="viewcode-block" id="spmatrix">
<a class="viewcode-back" href="../../../generated/dgl.sparse.spmatrix.html#dgl.sparse.spmatrix">[docs]</a>
<span class="k">def</span> <span class="nf">spmatrix</span><span class="p">(</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""Creates a sparse matrix from Coordinate format indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices : tensor.Tensor</span>
<span class="sd">        The indices are the coordinates of the non-zero elements in the matrix,</span>
<span class="sd">        which should have shape of ``(2, N)`` where the first row is the row</span>
<span class="sd">        indices and the second row is the column indices of non-zero elements.</span>
<span class="sd">    val : tensor.Tensor, optional</span>
<span class="sd">        The values of shape ``(nnz)`` or ``(nnz, D)``. If None, it will be a</span>
<span class="sd">        tensor of shape ``(nnz)`` filled by 1.</span>
<span class="sd">    shape : tuple[int, int], optional</span>
<span class="sd">        If not specified, it will be inferred from :attr:`row` and :attr:`col`,</span>
<span class="sd">        i.e., ``(row.max() + 1, col.max() + 1)``. Otherwise, :attr:`shape`</span>
<span class="sd">        should be no smaller than this.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Case1: Sparse matrix with row and column indices without values.</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.spmatrix(indices)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 5), nnz=3)</span>
<span class="sd">    &gt;&gt;&gt; # Specify shape</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(5, 5))</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(5, 5), nnz=3)</span>

<span class="sd">    Case2: Sparse matrix with scalar values.</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.tensor([[1.], [2.], [3.]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([[1.],</span>
<span class="sd">                                [2.],</span>
<span class="sd">                                [3.]]),</span>
<span class="sd">                 shape=(3, 5), nnz=3, val_size=(1,))</span>

<span class="sd">    Case3: Sparse matrix with vector values.</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.tensor([[1., 1.], [2., 2.], [3., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([[1., 1.],</span>
<span class="sd">                                [2., 2.],</span>
<span class="sd">                                [3., 3.]]),</span>
<span class="sd">                 shape=(3, 5), nnz=3, val_size=(2,))</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span>
    <span class="p">),</span> <span class="s2">"The values of a SparseMatrix can only be scalars or vectors."</span>
    <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">dgl_sparse</span><span class="o">.</span><span class="n">from_coo</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span></div>



<div class="viewcode-block" id="from_coo">
<a class="viewcode-back" href="../../../generated/dgl.sparse.from_coo.html#dgl.sparse.from_coo">[docs]</a>
<span class="k">def</span> <span class="nf">from_coo</span><span class="p">(</span>
    <span class="n">row</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">col</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""Creates a sparse matrix from a coordinate list (COO), which stores a list</span>
<span class="sd">    of (row, column, value) tuples.</span>

<span class="sd">    See `COO in Wikipedia</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_(COO)&gt;`_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    row : torch.Tensor</span>
<span class="sd">        The row indices of shape ``(nnz)``</span>
<span class="sd">    col : torch.Tensor</span>
<span class="sd">        The column indices of shape ``(nnz)``</span>
<span class="sd">    val : torch.Tensor, optional</span>
<span class="sd">        The values of shape ``(nnz)`` or ``(nnz, D)``. If None, it will be a</span>
<span class="sd">        tensor of shape ``(nnz)`` filled by 1.</span>
<span class="sd">    shape : tuple[int, int], optional</span>
<span class="sd">        If not specified, it will be inferred from :attr:`row` and :attr:`col`,</span>
<span class="sd">        i.e., ``(row.max() + 1, col.max() + 1)``. Otherwise, :attr:`shape`</span>
<span class="sd">        should be no smaller than this.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Case1: Sparse matrix with row and column indices without values.</span>

<span class="sd">    &gt;&gt;&gt; dst = torch.tensor([1, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; src = torch.tensor([2, 4, 3])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_coo(dst, src)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 5), nnz=3)</span>
<span class="sd">    &gt;&gt;&gt; # Specify shape</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_coo(dst, src, shape=(5, 5))</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(5, 5), nnz=3)</span>

<span class="sd">    Case2: Sparse matrix with scalar values.</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.tensor([[1.], [2.], [3.]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([[1.],</span>
<span class="sd">                                [2.],</span>
<span class="sd">                                [3.]]),</span>
<span class="sd">                 shape=(3, 5), nnz=3, val_size=(1,))</span>

<span class="sd">    Case3: Sparse matrix with vector values.</span>

<span class="sd">    &gt;&gt;&gt; dst = torch.tensor([1, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; src = torch.tensor([2, 4, 3])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.tensor([[1., 1.], [2., 2.], [3., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_coo(dst, src, val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([[1., 1.],</span>
<span class="sd">                                [2., 2.],</span>
<span class="sd">                                [3., 3.]]),</span>
<span class="sd">                 shape=(3, 5), nnz=3, val_size=(2,))</span>
<span class="sd">    """</span>
    <span class="k">assert</span> <span class="n">row</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]),</span> <span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>



<div class="viewcode-block" id="from_csr">
<a class="viewcode-back" href="../../../generated/dgl.sparse.from_csr.html#dgl.sparse.from_csr">[docs]</a>
<span class="k">def</span> <span class="nf">from_csr</span><span class="p">(</span>
    <span class="n">indptr</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""Creates a sparse matrix from compress sparse row (CSR) format.</span>

<span class="sd">    See `CSR in Wikipedia &lt;https://en.wikipedia.org/wiki/</span>
<span class="sd">    Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)&gt;`_.</span>

<span class="sd">    For row i of the sparse matrix</span>

<span class="sd">    - the column indices of the non-zero elements are stored in</span>
<span class="sd">      ``indices[indptr[i]: indptr[i+1]]``</span>
<span class="sd">    - the corresponding values are stored in ``val[indptr[i]: indptr[i+1]]``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indptr : torch.Tensor</span>
<span class="sd">        Pointer to the column indices of shape ``(N + 1)``, where ``N`` is the</span>
<span class="sd">        number of rows</span>
<span class="sd">    indices : torch.Tensor</span>
<span class="sd">        The column indices of shape ``(nnz)``</span>
<span class="sd">    val : torch.Tensor, optional</span>
<span class="sd">        The values of shape ``(nnz)`` or ``(nnz, D)``. If None, it will be a</span>
<span class="sd">        tensor of shape ``(nnz)`` filled by 1.</span>
<span class="sd">    shape : tuple[int, int], optional</span>
<span class="sd">        If not specified, it will be inferred from :attr:`indptr` and</span>
<span class="sd">        :attr:`indices`, i.e., ``(len(indptr) - 1, indices.max() + 1)``.</span>
<span class="sd">        Otherwise, :attr:`shape` should be no smaller than this.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Case1: Sparse matrix without values</span>

<span class="sd">    .. code::</span>

<span class="sd">        [[0, 1, 0],</span>
<span class="sd">         [0, 0, 1],</span>
<span class="sd">         [1, 1, 1]]</span>

<span class="sd">    &gt;&gt;&gt; indptr = torch.tensor([0, 1, 2, 5])</span>
<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([1, 2, 0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_csr(indptr, indices)</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2, 2, 2],</span>
<span class="sd">                                 [1, 2, 0, 1, 2]]),</span>
<span class="sd">                 values=tensor([1., 1., 1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 3), nnz=5)</span>
<span class="sd">    &gt;&gt;&gt; # Specify shape</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_csr(indptr, indices, shape=(3, 5))</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2, 2, 2],</span>
<span class="sd">                                 [1, 2, 0, 1, 2]]),</span>
<span class="sd">                 values=tensor([1., 1., 1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 5), nnz=5)</span>

<span class="sd">    Case2: Sparse matrix with scalar/vector values. Following example is with</span>
<span class="sd">    vector data.</span>

<span class="sd">    &gt;&gt;&gt; indptr = torch.tensor([0, 1, 2, 5])</span>
<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([1, 2, 0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.tensor([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_csr(indptr, indices, val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2, 2, 2],</span>
<span class="sd">                                 [1, 2, 0, 1, 2]]),</span>
<span class="sd">                 values=tensor([[1, 1],</span>
<span class="sd">                                [2, 2],</span>
<span class="sd">                                [3, 3],</span>
<span class="sd">                                [4, 4],</span>
<span class="sd">                                [5, 5]]),</span>
<span class="sd">                 shape=(3, 3), nnz=5, val_size=(2,))</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">indptr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">indptr</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span>
    <span class="p">),</span> <span class="s2">"The values of a SparseMatrix can only be scalars or vectors."</span>

    <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">dgl_sparse</span><span class="o">.</span><span class="n">from_csr</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="from_csc">
<a class="viewcode-back" href="../../../generated/dgl.sparse.from_csc.html#dgl.sparse.from_csc">[docs]</a>
<span class="k">def</span> <span class="nf">from_csc</span><span class="p">(</span>
    <span class="n">indptr</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""Creates a sparse matrix from compress sparse column (CSC) format.</span>

<span class="sd">    See `CSC in Wikipedia &lt;https://en.wikipedia.org/wiki/</span>
<span class="sd">    Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS)&gt;`_.</span>

<span class="sd">    For column i of the sparse matrix</span>

<span class="sd">    - the row indices of the non-zero elements are stored in</span>
<span class="sd">      ``indices[indptr[i]: indptr[i+1]]``</span>
<span class="sd">    - the corresponding values are stored in ``val[indptr[i]: indptr[i+1]]``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indptr : torch.Tensor</span>
<span class="sd">        Pointer to the row indices of shape N + 1, where N is the</span>
<span class="sd">        number of columns</span>
<span class="sd">    indices : torch.Tensor</span>
<span class="sd">        The row indices of shape nnz</span>
<span class="sd">    val : torch.Tensor, optional</span>
<span class="sd">        The values of shape ``(nnz)`` or ``(nnz, D)``. If None, it will be a</span>
<span class="sd">        tensor of shape ``(nnz)`` filled by 1.</span>
<span class="sd">    shape : tuple[int, int], optional</span>
<span class="sd">        If not specified, it will be inferred from :attr:`indptr` and</span>
<span class="sd">        :attr:`indices`, i.e., ``(indices.max() + 1, len(indptr) - 1)``.</span>
<span class="sd">        Otherwise, :attr:`shape` should be no smaller than this.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Case1: Sparse matrix without values</span>

<span class="sd">    .. code::</span>

<span class="sd">        [[0, 1, 0],</span>
<span class="sd">         [0, 0, 1],</span>
<span class="sd">         [1, 1, 1]]</span>

<span class="sd">    &gt;&gt;&gt; indptr = torch.tensor([0, 1, 3, 5])</span>
<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([2, 0, 2, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_csc(indptr, indices)</span>
<span class="sd">    SparseMatrix(indices=tensor([[2, 0, 2, 1, 2],</span>
<span class="sd">                                 [0, 1, 1, 2, 2]]),</span>
<span class="sd">                 values=tensor([1., 1., 1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 3), nnz=5)</span>
<span class="sd">    &gt;&gt;&gt; # Specify shape</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_csc(indptr, indices, shape=(5, 3))</span>
<span class="sd">    SparseMatrix(indices=tensor([[2, 0, 2, 1, 2],</span>
<span class="sd">                                 [0, 1, 1, 2, 2]]),</span>
<span class="sd">                 values=tensor([1., 1., 1., 1., 1.]),</span>
<span class="sd">                 shape=(5, 3), nnz=5)</span>

<span class="sd">    Case2: Sparse matrix with scalar/vector values. Following example is with</span>
<span class="sd">    vector data.</span>

<span class="sd">    &gt;&gt;&gt; indptr = torch.tensor([0, 1, 3, 5])</span>
<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([2, 0, 2, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.tensor([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_csc(indptr, indices, val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[2, 0, 2, 1, 2],</span>
<span class="sd">                                 [0, 1, 1, 2, 2]]),</span>
<span class="sd">                 values=tensor([[1, 1],</span>
<span class="sd">                                [2, 2],</span>
<span class="sd">                                [3, 3],</span>
<span class="sd">                                [4, 4],</span>
<span class="sd">                                [5, 5]]),</span>
<span class="sd">                 shape=(3, 3), nnz=5, val_size=(2,))</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">indptr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">indptr</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span>
    <span class="p">),</span> <span class="s2">"The values of a SparseMatrix can only be scalars or vectors."</span>

    <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">dgl_sparse</span><span class="o">.</span><span class="n">from_csc</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="val_like">
<a class="viewcode-back" href="../../../generated/dgl.sparse.val_like.html#dgl.sparse.val_like">[docs]</a>
<span class="k">def</span> <span class="nf">val_like</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">SparseMatrix</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Creates a sparse matrix from an existing sparse matrix using new values.</span>

<span class="sd">    The new sparse matrix will have the same non-zero indices as the given</span>
<span class="sd">    sparse matrix and use the given values as the new non-zero values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : SparseMatrix</span>
<span class="sd">        An existing sparse matrix with non-zero values</span>
<span class="sd">    val : torch.Tensor</span>
<span class="sd">        The new values of the non-zero elements, a tensor of shape ``(nnz)`` or</span>
<span class="sd">        ``(nnz, D)``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        New sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.ones(3)</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.val_like(A, torch.tensor([2, 2, 2]))</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([2, 2, 2]),</span>
<span class="sd">                 shape=(3, 5), nnz=3)</span>
<span class="sd">    """</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span>
    <span class="p">),</span> <span class="s2">"The values of a SparseMatrix can only be scalars or vectors."</span>

    <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">dgl_sparse</span><span class="o">.</span><span class="n">val_like</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span></div>



<div class="viewcode-block" id="diag">
<a class="viewcode-back" href="../../../generated/dgl.sparse.diag.html#dgl.sparse.diag">[docs]</a>
<span class="k">def</span> <span class="nf">diag</span><span class="p">(</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Creates a sparse matrix based on the diagonal values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    val : torch.Tensor</span>
<span class="sd">        Diagonal of the matrix, in shape ``(N)`` or ``(N, D)``</span>
<span class="sd">    shape : tuple[int, int], optional</span>
<span class="sd">        If specified, :attr:`len(val)` must be equal to :attr:`min(shape)`,</span>
<span class="sd">        otherwise, it will be inferred from :attr:`val`, i.e., ``(N, N)``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Case1: 5-by-5 diagonal matrix with scaler values on the diagonal</span>

<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; val = torch.ones(5)</span>
<span class="sd">    &gt;&gt;&gt; dglsp.diag(val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2, 3, 4],</span>
<span class="sd">                                 [0, 1, 2, 3, 4]]),</span>
<span class="sd">                 values=tensor([1., 1., 1., 1., 1.]),</span>
<span class="sd">                 shape=(5, 5), nnz=5)</span>

<span class="sd">    Case2: 5-by-10 diagonal matrix with scaler values on the diagonal</span>

<span class="sd">    &gt;&gt;&gt; val = torch.ones(5)</span>
<span class="sd">    &gt;&gt;&gt; dglsp.diag(val, shape=(5, 10))</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2, 3, 4],</span>
<span class="sd">                                 [0, 1, 2, 3, 4]]),</span>
<span class="sd">                 values=tensor([1., 1., 1., 1., 1.]),</span>
<span class="sd">                 shape=(5, 10), nnz=5)</span>

<span class="sd">    Case3: 5-by-5 diagonal matrix with vector values on the diagonal</span>

<span class="sd">    &gt;&gt;&gt; val = torch.randn(5, 3)</span>
<span class="sd">    &gt;&gt;&gt; D = dglsp.diag(val)</span>
<span class="sd">    &gt;&gt;&gt; D.shape</span>
<span class="sd">    (5, 5)</span>
<span class="sd">    &gt;&gt;&gt; D.nnz</span>
<span class="sd">    5</span>
<span class="sd">    """</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span>
    <span class="p">),</span> <span class="s2">"The values of a DiagMatrix can only be scalars or vectors."</span>
    <span class="n">len_val</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">len_val</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">"Expect len(val) to be min(shape) for a diagonal matrix, got"</span>
            <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">len_val</span><span class="si">}</span><span class="s2"> for len(val) and </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2"> for shape."</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">len_val</span><span class="p">,</span> <span class="n">len_val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">dgl_sparse</span><span class="o">.</span><span class="n">from_diag</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span></div>



<div class="viewcode-block" id="identity">
<a class="viewcode-back" href="../../../generated/dgl.sparse.identity.html#dgl.sparse.identity">[docs]</a>
<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">d</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""Creates a sparse matrix with ones on the diagonal and zeros elsewhere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : tuple[int, int]</span>
<span class="sd">        Shape of the matrix.</span>
<span class="sd">    d : int, optional</span>
<span class="sd">        If None, the diagonal entries will be scaler 1. Otherwise, the diagonal</span>
<span class="sd">        entries will be a 1-valued tensor of shape ``(d)``.</span>
<span class="sd">    dtype : torch.dtype, optional</span>
<span class="sd">        The data type of the matrix</span>
<span class="sd">    device : torch.device, optional</span>
<span class="sd">        The device of the matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Case1: 3-by-3 matrix with scaler diagonal values</span>

<span class="sd">    .. code::</span>

<span class="sd">        [[1, 0, 0],</span>
<span class="sd">         [0, 1, 0],</span>
<span class="sd">         [0, 0, 1]]</span>

<span class="sd">    &gt;&gt;&gt; dglsp.identity(shape=(3, 3))</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2],</span>
<span class="sd">                                 [0, 1, 2]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 3), nnz=3)</span>

<span class="sd">    Case2: 3-by-5 matrix with scaler diagonal values</span>

<span class="sd">    .. code::</span>

<span class="sd">        [[1, 0, 0, 0, 0],</span>
<span class="sd">         [0, 1, 0, 0, 0],</span>
<span class="sd">         [0, 0, 1, 0, 0]]</span>

<span class="sd">    &gt;&gt;&gt; dglsp.identity(shape=(3, 5))</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2],</span>
<span class="sd">                                 [0, 1, 2]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 5), nnz=3)</span>

<span class="sd">    Case3: 3-by-3 matrix with vector diagonal values</span>

<span class="sd">    &gt;&gt;&gt; dglsp.identity(shape=(3, 3), d=2)</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2],</span>
<span class="sd">                                 [0, 1, 2]]),</span>
<span class="sd">                 values=tensor([[1., 1.],</span>
<span class="sd">                                [1., 1.],</span>
<span class="sd">                                [1., 1.]]),</span>
<span class="sd">                 shape=(3, 3), nnz=3, val_size=(2,))</span>
<span class="sd">    """</span>
    <span class="n">len_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">len_val</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">val_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">len_val</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">val_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">diag</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">from_torch_sparse</span><span class="p">(</span><span class="n">torch_sparse_tensor</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Creates a sparse matrix from a torch sparse tensor, which can have coo,</span>
<span class="sd">    csr, or csc layout.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    torch_sparse_tensor : torch.Tensor</span>
<span class="sd">        Torch sparse tensor</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.ones(3)</span>
<span class="sd">    &gt;&gt;&gt; torch_coo = torch.sparse_coo_tensor(indices, val)</span>
<span class="sd">    &gt;&gt;&gt; dglsp.from_torch_sparse(torch_coo)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 5), nnz=3)</span>
<span class="sd">    """</span>
    <span class="k">assert</span> <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">layout</span> <span class="ow">in</span> <span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo</span><span class="p">,</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">sparse_csr</span><span class="p">,</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">sparse_csc</span><span class="p">,</span>
    <span class="p">),</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">"Cannot convert Pytorch sparse tensor with layout "</span>
        <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">layout</span><span class="si">}</span><span class="s2"> to DGL sparse."</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo</span><span class="p">:</span>
        <span class="c1"># Use ._indices() and ._values() to access uncoalesced indices and</span>
        <span class="c1"># values.</span>
        <span class="k">return</span> <span class="n">spmatrix</span><span class="p">(</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">_indices</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">_values</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_csr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">from_csr</span><span class="p">(</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">crow_indices</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">col_indices</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">from_csc</span><span class="p">(</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">ccol_indices</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">row_indices</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">to_torch_sparse_coo</span><span class="p">(</span><span class="n">spmat</span><span class="p">:</span> <span class="n">SparseMatrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Creates a torch sparse coo tensor from a sparse matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spmat : SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">        torch tensor with torch.sparse_coo layout</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.ones(3)</span>
<span class="sd">    &gt;&gt;&gt; spmat = dglsp.spmatrix(indices, val)</span>
<span class="sd">    &gt;&gt;&gt; dglsp.to_torch_sparse_coo(spmat)</span>
<span class="sd">    tensor(indices=tensor([[1, 1, 2],</span>
<span class="sd">                           [2, 4, 3]]),</span>
<span class="sd">           values=tensor([1., 1., 1.]),</span>
<span class="sd">           size=(3, 5), nnz=3, layout=torch.sparse_coo)</span>
<span class="sd">    """</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">+=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="n">spmat</span><span class="o">.</span><span class="n">indices</span><span class="p">(),</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">to_torch_sparse_csr</span><span class="p">(</span><span class="n">spmat</span><span class="p">:</span> <span class="n">SparseMatrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Creates a torch sparse csr tensor from a sparse matrix.</span>

<span class="sd">    Note that converting a sparse matrix to torch csr tensor could change the</span>
<span class="sd">    order of non-zero values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spmat : SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">        Torch tensor with torch.sparse_csr layout</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 2, 1], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.arange(3)</span>
<span class="sd">    &gt;&gt;&gt; spmat = dglsp.spmatrix(indices, val)</span>
<span class="sd">    &gt;&gt;&gt; dglsp.to_torch_sparse_csr(spmat)</span>
<span class="sd">    tensor(crow_indices=tensor([0, 0, 2, 3]),</span>
<span class="sd">           col_indices=tensor([2, 3, 4]),</span>
<span class="sd">           values=tensor([0, 2, 1]), size=(3, 5), nnz=3,</span>
<span class="sd">           layout=torch.sparse_csr)</span>
<span class="sd">    """</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">+=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">value_indices</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">csr</span><span class="p">()</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span>
    <span class="k">if</span> <span class="n">value_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">value_indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_csr_tensor</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">to_torch_sparse_csc</span><span class="p">(</span><span class="n">spmat</span><span class="p">:</span> <span class="n">SparseMatrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Creates a torch sparse csc tensor from a sparse matrix.</span>

<span class="sd">    Note that converting a sparse matrix to torch csc tensor could change the</span>
<span class="sd">    order of non-zero values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spmat : SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">        Torch tensor with torch.sparse_csc layout</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 2, 1], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.arange(3)</span>
<span class="sd">    &gt;&gt;&gt; spmat = dglsp.spmatrix(indices, val)</span>
<span class="sd">    &gt;&gt;&gt; dglsp.to_torch_sparse_csc(spmat)</span>
<span class="sd">    tensor(ccol_indices=tensor([0, 0, 0, 1, 2, 3]),</span>
<span class="sd">           row_indices=tensor([1, 1, 2]),</span>
<span class="sd">           values=tensor([0, 2, 1]), size=(3, 5), nnz=3,</span>
<span class="sd">           layout=torch.sparse_csc)</span>
<span class="sd">    """</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">+=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">value_indices</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">csc</span><span class="p">()</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span>
    <span class="k">if</span> <span class="n">value_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">value_indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_csc_tensor</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sparse_matrix_str</span><span class="p">(</span><span class="n">spmat</span><span class="p">:</span> <span class="n">SparseMatrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Internal function for converting a sparse matrix to string</span>
<span class="sd">    representation.</span>
<span class="sd">    """</span>
    <span class="n">indices_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">spmat</span><span class="o">.</span><span class="n">coo</span><span class="p">()))</span>
    <span class="n">values_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="n">meta_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"shape=</span><span class="si">{</span><span class="n">spmat</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, nnz=</span><span class="si">{</span><span class="n">spmat</span><span class="o">.</span><span class="n">nnz</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">if</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">val_size</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">meta_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">", val_size=</span><span class="si">{</span><span class="n">val_size</span><span class="si">}</span><span class="s2">"</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">spmat</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">("</span>

    <span class="k">def</span> <span class="nf">_add_indent</span><span class="p">(</span><span class="n">_str</span><span class="p">,</span> <span class="n">indent</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="s2">" "</span> <span class="o">*</span> <span class="n">indent</span> <span class="o">+</span> <span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="k">return</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="n">final_str</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">"indices="</span>
        <span class="o">+</span> <span class="n">_add_indent</span><span class="p">(</span><span class="n">indices_str</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="s2">"indices="</span><span class="p">))</span>
        <span class="o">+</span> <span class="s2">",</span><span class="se">\n</span><span class="s2">"</span>
        <span class="o">+</span> <span class="s2">"values="</span>
        <span class="o">+</span> <span class="n">_add_indent</span><span class="p">(</span><span class="n">values_str</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="s2">"values="</span><span class="p">))</span>
        <span class="o">+</span> <span class="s2">",</span><span class="se">\n</span><span class="s2">"</span>
        <span class="o">+</span> <span class="n">meta_str</span>
        <span class="o">+</span> <span class="s2">")"</span>
    <span class="p">)</span>
    <span class="n">final_str</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">_add_indent</span><span class="p">(</span><span class="n">final_str</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">final_str</span>
</pre></div>
</div>
</div>
<footer>
<hr/>
<div role="contentinfo">
<p>© Copyright 2018, DGL Team.</p>
</div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" data-toggle="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span class="fa fa-book"> Read the Docs</span>
<span id="version-placeholder">v: latest</span>
<span class="fa fa-caret-down"></span>
</span>
<div class="rst-other-versions">
<dl>
<dt>Versions</dt>
<div id="version-list">
<!-- 动态插入的版本列表将出现在这里 -->
</div>
</dl>
<dl>
<dt>Downloads</dt>
<!-- 下载内容 -->
</dl>
<dl>
<dt>On Read the Docs</dt>
<dd><a href="//doc-build.dgl.ai/projects/dgl/?fromdocs=dgl">Project Home</a></dd>
<dd><a href="//doc-build.dgl.ai/builds/dgl/?fromdocs=dgl">Builds</a></dd>
</dl>
</div>
</div>
<script>
        document.addEventListener("DOMContentLoaded", function() {
            fetch('/dgl_docs/branches.json')
                .then(response => response.json())
                .then(data => {
                    var versionListDiv = document.getElementById('version-list');
                    data.branches.forEach(function(branch) {
                        var dd = document.createElement('dd');
                        var a = document.createElement('a');
                        a.href = branch.url;
                        a.textContent = branch.name;
                        dd.appendChild(a);
                        versionListDiv.appendChild(dd);
                    });
                })
                .catch(error => console.error('Error loading branches:', error));
        });
        document.addEventListener("DOMContentLoaded", function() {
            // 获取当前路径
            var path = window.location.pathname;
            var versionPlaceholder = document.getElementById('version-placeholder');

            // 检查路径中是否包含 'en'
            if (path.includes('/en/')) {
                // 提取 'en' 后的文件夹作为版本号
                var parts = path.split('/en/');
                if (parts[1]) {
                    var folders = parts[1].split('/');
                    if (folders.length > 0 && folders[0]) {
                        versionPlaceholder.textContent = 'v: ' + folders[0];
                    } else {
                        versionPlaceholder.textContent = 'v: latest';
                    }
                } else {
                    versionPlaceholder.textContent = 'v: latest';
                }
            } else {
                versionPlaceholder.textContent = 'v: latest';
            }
        });
    </script>

<div aria-label="Versions" class="rst-versions" data-toggle="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span class="fa fa-book"> Read the Docs</span>
<span id="version-placeholder">v: latest</span>
<span class="fa fa-caret-down"></span>
</span>
<div class="rst-other-versions">
<dl>
<dt>Versions</dt>
<div id="version-list">
<!-- 动态插入的版本列表将出现在这里 -->
</div>
</dl>
<dl>
<dt>Downloads</dt>
<!-- 下载内容 -->
</dl>
<dl>
<dt>On Read the Docs</dt>
<dd><a href="//doc-build.dgl.ai/projects/dgl/?fromdocs=dgl">Project Home</a></dd>
<dd><a href="//doc-build.dgl.ai/builds/dgl/?fromdocs=dgl">Builds</a></dd>
</dl>
</div>
</div>
<script>
        document.addEventListener("DOMContentLoaded", function() {
            fetch('/dgl_docs/branches.json')
                .then(response => response.json())
                .then(data => {
                    var versionListDiv = document.getElementById('version-list');
                    data.branches.forEach(function(branch) {
                        var dd = document.createElement('dd');
                        var a = document.createElement('a');
                        a.href = branch.url;
                        a.textContent = branch.name;
                        dd.appendChild(a);
                        versionListDiv.appendChild(dd);
                    });
                })
                .catch(error => console.error('Error loading branches:', error));
        });
        document.addEventListener("DOMContentLoaded", function() {
            // 获取当前路径
            var path = window.location.pathname;
            var versionPlaceholder = document.getElementById('version-placeholder');

            // 检查路径中是否包含 'en'
            if (path.includes('/en/')) {
                // 提取 'en' 后的文件夹作为版本号
                var parts = path.split('/en/');
                if (parts[1]) {
                    var folders = parts[1].split('/');
                    if (folders.length > 0 && folders[0]) {
                        versionPlaceholder.textContent = 'v: ' + folders[0];
                    } else {
                        versionPlaceholder.textContent = 'v: latest';
                    }
                } else {
                    versionPlaceholder.textContent = 'v: latest';
                }
            } else {
                versionPlaceholder.textContent = 'v: latest';
            }
        });
    </script>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>