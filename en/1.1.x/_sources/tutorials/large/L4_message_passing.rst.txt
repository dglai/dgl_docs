
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/large/L4_message_passing.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials_large_L4_message_passing.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_large_L4_message_passing.py:


Writing GNN Modules for Stochastic GNN Training
===============================================

All GNN modules DGL provides support stochastic GNN training. This
tutorial teaches you how to write your own graph neural network module
for stochastic GNN training. It assumes that

1. You know :doc:`how to write GNN modules for full graph
   training <../blitz/3_message_passing>`.
2. You know :doc:`how stochastic GNN training pipeline
   works <L1_large_node_classification>`.

.. GENERATED FROM PYTHON SOURCE LINES 15-49

.. code-block:: Python


    import os

    os.environ["DGLBACKEND"] = "pytorch"
    import dgl
    import numpy as np
    import torch
    from ogb.nodeproppred import DglNodePropPredDataset

    dataset = DglNodePropPredDataset("ogbn-arxiv")
    device = "cpu"  # change to 'cuda' for GPU

    graph, node_labels = dataset[0]
    # Add reverse edges since ogbn-arxiv is unidirectional.
    graph = dgl.add_reverse_edges(graph)
    graph.ndata["label"] = node_labels[:, 0]
    idx_split = dataset.get_idx_split()
    train_nids = idx_split["train"]
    node_features = graph.ndata["feat"]

    sampler = dgl.dataloading.MultiLayerNeighborSampler([4, 4])
    train_dataloader = dgl.dataloading.DataLoader(
        graph,
        train_nids,
        sampler,
        batch_size=1024,
        shuffle=True,
        drop_last=False,
        num_workers=0,
    )

    input_nodes, output_nodes, mfgs = next(iter(train_dataloader))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/ubuntu/regression_test/dgl/python/dgl/dataloading/dataloader.py:1149: DGLWarning: Dataloader CPU affinity opt is not enabled, consider switching it on (see enable_cpu_affinity() or CPU best practices for DGL [https://docs.dgl.ai/tutorials/cpu/cpu_best_practises.html])
      dgl_warning(




.. GENERATED FROM PYTHON SOURCE LINES 50-62

DGL Bipartite Graph Introduction
--------------------------------

In the previous tutorials, you have seen the concept *message flow graph*
(MFG), where nodes are divided into two parts.  It is a kind of (directional)
bipartite graph.
This section introduces how you can manipulate (directional) bipartite
graphs.

You can access the source node features and destination node features via
``srcdata`` and ``dstdata`` attributes:


.. GENERATED FROM PYTHON SOURCE LINES 62-68

.. code-block:: Python


    mfg = mfgs[0]
    print(mfg.srcdata)
    print(mfg.dstdata)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    {'year': tensor([[2017],
            [2016],
            [2015],
            ...,
            [2011],
            [2007],
            [2019]]), 'feat': tensor([[-0.1168, -0.1182, -0.2456,  ...,  0.2151, -0.0071, -0.0602],
            [-0.0973, -0.0505, -0.0893,  ...,  0.1422,  0.0696, -0.1824],
            [-0.2626, -0.0460, -0.2903,  ...,  0.0033, -0.1027, -0.0458],
            ...,
            [ 0.0181, -0.0340, -0.1303,  ...,  0.0924, -0.1212, -0.0211],
            [-0.0859,  0.0176, -0.0373,  ...,  0.2608, -0.1355, -0.2589],
            [-0.1608, -0.0145, -0.2417,  ..., -0.0902, -0.0288, -0.2383]]), 'label': tensor([13, 10, 16,  ..., 17, 16, 28]), '_ID': tensor([ 35250, 152499,  36696,  ...,  92804,  88798,  78748])}
    {'year': tensor([[2017],
            [2016],
            [2015],
            ...,
            [2010],
            [2009],
            [2016]]), 'feat': tensor([[-0.1168, -0.1182, -0.2456,  ...,  0.2151, -0.0071, -0.0602],
            [-0.0973, -0.0505, -0.0893,  ...,  0.1422,  0.0696, -0.1824],
            [-0.2626, -0.0460, -0.2903,  ...,  0.0033, -0.1027, -0.0458],
            ...,
            [-0.1367, -0.0487, -0.3453,  ...,  0.1074, -0.1476, -0.1192],
            [-0.1380,  0.0343, -0.1611,  ...,  0.0967, -0.1249,  0.0419],
            [-0.1512, -0.1505, -0.2647,  ...,  0.1027, -0.0660, -0.0865]]), 'label': tensor([13, 10, 16,  ..., 16, 16, 28]), '_ID': tensor([ 35250, 152499,  36696,  ...,  46682,  57189,  87332])}




.. GENERATED FROM PYTHON SOURCE LINES 69-72

It also has ``num_src_nodes`` and ``num_dst_nodes`` functions to query
how many source nodes and destination nodes exist in the bipartite graph:


.. GENERATED FROM PYTHON SOURCE LINES 72-76

.. code-block:: Python


    print(mfg.num_src_nodes(), mfg.num_dst_nodes())






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    12568 4025




.. GENERATED FROM PYTHON SOURCE LINES 77-80

You can assign features to ``srcdata`` and ``dstdata`` just as what you
will do with ``ndata`` on the graphs you have seen earlier:


.. GENERATED FROM PYTHON SOURCE LINES 80-85

.. code-block:: Python


    mfg.srcdata["x"] = torch.zeros(mfg.num_src_nodes(), mfg.num_dst_nodes())
    dst_feat = mfg.dstdata["feat"]









.. GENERATED FROM PYTHON SOURCE LINES 86-91

Also, since the bipartite graphs are constructed by DGL, you can
retrieve the source node IDs (i.e. those that are required to compute the
output) and destination node IDs (i.e. those whose representations the
current GNN layer should compute) as follows.


.. GENERATED FROM PYTHON SOURCE LINES 91-95

.. code-block:: Python


    mfg.srcdata[dgl.NID], mfg.dstdata[dgl.NID]






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (tensor([ 35250, 152499,  36696,  ...,  92804,  88798,  78748]), tensor([ 35250, 152499,  36696,  ...,  46682,  57189,  87332]))



.. GENERATED FROM PYTHON SOURCE LINES 96-99

Writing GNN Modules for Bipartite Graphs for Stochastic Training
----------------------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 102-110

Recall that the MFGs yielded by the ``DataLoader``
have the property that the first few source nodes are
always identical to the destination nodes:

|image1|

.. |image1| image:: https://data.dgl.ai/tutorial/img/bipartite.gif


.. GENERATED FROM PYTHON SOURCE LINES 110-118

.. code-block:: Python


    print(
        torch.equal(
            mfg.srcdata[dgl.NID][: mfg.num_dst_nodes()], mfg.dstdata[dgl.NID]
        )
    )






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    True




.. GENERATED FROM PYTHON SOURCE LINES 119-122

Suppose you have obtained the source node representations
:math:`h_u^{(l-1)}`:


.. GENERATED FROM PYTHON SOURCE LINES 122-126

.. code-block:: Python


    mfg.srcdata["h"] = torch.randn(mfg.num_src_nodes(), 10)









.. GENERATED FROM PYTHON SOURCE LINES 127-139

Recall that DGL provides the `update_all` interface for expressing how
to compute messages and how to aggregate them on the nodes that receive
them. This concept naturally applies to bipartite graphs like MFGs -- message
computation happens on the edges between source and destination nodes of
the edges, and message aggregation happens on the destination nodes.

For example, suppose the message function copies the source feature
(i.e. :math:`M^{(l)}\left(h_v^{(l-1)}, h_u^{(l-1)}, e_{u\to v}^{(l-1)}\right) = h_v^{(l-1)}`),
and the reduce function averages the received messages.  Performing
such message passing computation on a bipartite graph is no different than
on a full graph:


.. GENERATED FROM PYTHON SOURCE LINES 139-147

.. code-block:: Python


    import dgl.function as fn

    mfg.update_all(message_func=fn.copy_u("h", "m"), reduce_func=fn.mean("m", "h"))
    m_v = mfg.dstdata["h"]
    m_v






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    tensor([[-0.1888,  1.5974, -0.0909,  ..., -1.4438,  0.5403,  2.2982],
            [-0.8896, -0.2780, -0.8172,  ..., -0.2212,  0.2309, -0.0439],
            [-0.1867, -1.0624, -0.6307,  ..., -1.2935,  0.1634, -0.3588],
            ...,
            [ 0.1179,  0.6841, -0.0827,  ..., -0.9045, -0.0918, -0.4322],
            [-0.4449,  1.0739, -0.1656,  ..., -0.2767,  1.1809, -1.1255],
            [ 0.0853, -0.2330,  0.2115,  ...,  0.2356, -0.5149,  0.3193]])



.. GENERATED FROM PYTHON SOURCE LINES 148-152

Putting them together, you can implement a GraphSAGE convolution for
training with neighbor sampling as follows (the differences to the :doc:`full graph
counterpart <../blitz/3_message_passing>` are highlighted with arrows ``<---``)


.. GENERATED FROM PYTHON SOURCE LINES 152-230

.. code-block:: Python


    import torch.nn as nn
    import torch.nn.functional as F
    import tqdm


    class SAGEConv(nn.Module):
        """Graph convolution module used by the GraphSAGE model.

        Parameters
        ----------
        in_feat : int
            Input feature size.
        out_feat : int
            Output feature size.
        """

        def __init__(self, in_feat, out_feat):
            super(SAGEConv, self).__init__()
            # A linear submodule for projecting the input and neighbor feature to the output.
            self.linear = nn.Linear(in_feat * 2, out_feat)

        def forward(self, g, h):
            """Forward computation

            Parameters
            ----------
            g : Graph
                The input MFG.
            h : (Tensor, Tensor)
                The feature of source nodes and destination nodes as a pair of Tensors.
            """
            with g.local_scope():
                h_src, h_dst = h
                g.srcdata["h"] = h_src  # <---
                g.dstdata["h"] = h_dst  # <---
                # update_all is a message passing API.
                g.update_all(fn.copy_u("h", "m"), fn.mean("m", "h_N"))
                h_N = g.dstdata["h_N"]
                h_total = torch.cat([h_dst, h_N], dim=1)  # <---
                return self.linear(h_total)


    class Model(nn.Module):
        def __init__(self, in_feats, h_feats, num_classes):
            super(Model, self).__init__()
            self.conv1 = SAGEConv(in_feats, h_feats)
            self.conv2 = SAGEConv(h_feats, num_classes)

        def forward(self, mfgs, x):
            h_dst = x[: mfgs[0].num_dst_nodes()]
            h = self.conv1(mfgs[0], (x, h_dst))
            h = F.relu(h)
            h_dst = h[: mfgs[1].num_dst_nodes()]
            h = self.conv2(mfgs[1], (h, h_dst))
            return h


    sampler = dgl.dataloading.MultiLayerNeighborSampler([4, 4])
    train_dataloader = dgl.dataloading.DataLoader(
        graph,
        train_nids,
        sampler,
        device=device,
        batch_size=1024,
        shuffle=True,
        drop_last=False,
        num_workers=0,
    )
    model = Model(graph.ndata["feat"].shape[1], 128, dataset.num_classes).to(device)

    with tqdm.tqdm(train_dataloader) as tq:
        for step, (input_nodes, output_nodes, mfgs) in enumerate(tq):
            inputs = mfgs[0].srcdata["feat"]
            labels = mfgs[-1].dstdata["label"]
            predictions = model(mfgs, inputs)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/89 [00:00<?, ?it/s]      1%|          | 1/89 [00:00<00:15,  5.73it/s]      2%|▏         | 2/89 [00:00<00:20,  4.26it/s]      3%|▎         | 3/89 [00:00<00:21,  3.93it/s]      4%|▍         | 4/89 [00:01<00:22,  3.74it/s]      6%|▌         | 5/89 [00:01<00:22,  3.72it/s]      7%|▋         | 6/89 [00:01<00:22,  3.74it/s]      8%|▊         | 7/89 [00:01<00:21,  3.74it/s]      9%|▉         | 8/89 [00:02<00:22,  3.66it/s]     10%|█         | 9/89 [00:02<00:22,  3.51it/s]     11%|█         | 10/89 [00:02<00:21,  3.62it/s]     12%|█▏        | 11/89 [00:02<00:22,  3.48it/s]     13%|█▎        | 12/89 [00:03<00:22,  3.44it/s]     15%|█▍        | 13/89 [00:03<00:21,  3.48it/s]     16%|█▌        | 14/89 [00:03<00:21,  3.49it/s]     17%|█▋        | 15/89 [00:04<00:20,  3.65it/s]     18%|█▊        | 16/89 [00:04<00:19,  3.79it/s]     19%|█▉        | 17/89 [00:04<00:19,  3.74it/s]     20%|██        | 18/89 [00:04<00:19,  3.73it/s]     21%|██▏       | 19/89 [00:05<00:20,  3.46it/s]     22%|██▏       | 20/89 [00:05<00:19,  3.57it/s]     24%|██▎       | 21/89 [00:05<00:18,  3.58it/s]     25%|██▍       | 22/89 [00:05<00:17,  3.74it/s]     26%|██▌       | 23/89 [00:06<00:19,  3.42it/s]     27%|██▋       | 24/89 [00:06<00:18,  3.54it/s]     28%|██▊       | 25/89 [00:06<00:18,  3.55it/s]     29%|██▉       | 26/89 [00:07<00:18,  3.43it/s]     30%|███       | 27/89 [00:07<00:17,  3.45it/s]     31%|███▏      | 28/89 [00:07<00:17,  3.58it/s]     33%|███▎      | 29/89 [00:08<00:17,  3.41it/s]     34%|███▎      | 30/89 [00:08<00:17,  3.37it/s]     35%|███▍      | 31/89 [00:08<00:16,  3.45it/s]     36%|███▌      | 32/89 [00:08<00:16,  3.35it/s]     37%|███▋      | 33/89 [00:09<00:16,  3.44it/s]     38%|███▊      | 34/89 [00:09<00:15,  3.54it/s]     39%|███▉      | 35/89 [00:09<00:14,  3.69it/s]     40%|████      | 36/89 [00:10<00:14,  3.71it/s]     42%|████▏     | 37/89 [00:10<00:14,  3.71it/s]     43%|████▎     | 38/89 [00:10<00:13,  3.72it/s]     44%|████▍     | 39/89 [00:10<00:13,  3.70it/s]     45%|████▍     | 40/89 [00:11<00:13,  3.74it/s]     46%|████▌     | 41/89 [00:11<00:13,  3.63it/s]     47%|████▋     | 42/89 [00:11<00:13,  3.61it/s]     48%|████▊     | 43/89 [00:11<00:12,  3.62it/s]     49%|████▉     | 44/89 [00:12<00:12,  3.68it/s]     51%|█████     | 45/89 [00:12<00:12,  3.62it/s]     52%|█████▏    | 46/89 [00:12<00:11,  3.68it/s]     53%|█████▎    | 47/89 [00:13<00:11,  3.55it/s]     54%|█████▍    | 48/89 [00:13<00:11,  3.66it/s]     55%|█████▌    | 49/89 [00:13<00:10,  3.75it/s]     56%|█████▌    | 50/89 [00:13<00:10,  3.81it/s]     57%|█████▋    | 51/89 [00:14<00:09,  3.88it/s]     58%|█████▊    | 52/89 [00:14<00:09,  3.81it/s]     60%|█████▉    | 53/89 [00:14<00:09,  3.80it/s]     61%|██████    | 54/89 [00:14<00:09,  3.65it/s]     62%|██████▏   | 55/89 [00:15<00:09,  3.63it/s]     63%|██████▎   | 56/89 [00:15<00:08,  3.67it/s]     64%|██████▍   | 57/89 [00:15<00:08,  3.65it/s]     65%|██████▌   | 58/89 [00:16<00:08,  3.47it/s]     66%|██████▋   | 59/89 [00:16<00:08,  3.61it/s]     67%|██████▋   | 60/89 [00:16<00:08,  3.53it/s]     69%|██████▊   | 61/89 [00:16<00:07,  3.64it/s]     70%|██████▉   | 62/89 [00:17<00:07,  3.55it/s]     71%|███████   | 63/89 [00:17<00:07,  3.61it/s]     72%|███████▏  | 64/89 [00:17<00:06,  3.65it/s]     73%|███████▎  | 65/89 [00:17<00:06,  3.54it/s]     74%|███████▍  | 66/89 [00:18<00:06,  3.60it/s]     75%|███████▌  | 67/89 [00:18<00:06,  3.59it/s]     76%|███████▋  | 68/89 [00:18<00:05,  3.61it/s]     78%|███████▊  | 69/89 [00:19<00:05,  3.68it/s]     79%|███████▊  | 70/89 [00:19<00:05,  3.60it/s]     80%|███████▉  | 71/89 [00:19<00:05,  3.55it/s]     81%|████████  | 72/89 [00:19<00:04,  3.59it/s]     82%|████████▏ | 73/89 [00:20<00:04,  3.64it/s]     83%|████████▎ | 74/89 [00:20<00:04,  3.49it/s]     84%|████████▍ | 75/89 [00:20<00:04,  3.48it/s]     85%|████████▌ | 76/89 [00:21<00:03,  3.41it/s]     87%|████████▋ | 77/89 [00:21<00:03,  3.31it/s]     88%|████████▊ | 78/89 [00:21<00:03,  3.35it/s]     89%|████████▉ | 79/89 [00:21<00:02,  3.52it/s]     90%|████████▉ | 80/89 [00:22<00:02,  3.58it/s]     91%|█████████ | 81/89 [00:22<00:02,  3.58it/s]     92%|█████████▏| 82/89 [00:22<00:01,  3.65it/s]     93%|█████████▎| 83/89 [00:23<00:01,  3.63it/s]     94%|█████████▍| 84/89 [00:23<00:01,  3.69it/s]     96%|█████████▌| 85/89 [00:23<00:01,  3.47it/s]     97%|█████████▋| 86/89 [00:23<00:00,  3.61it/s]     98%|█████████▊| 87/89 [00:24<00:00,  3.78it/s]     99%|█████████▉| 88/89 [00:24<00:00,  3.66it/s]    100%|██████████| 89/89 [00:24<00:00,  3.75it/s]    100%|██████████| 89/89 [00:24<00:00,  3.61it/s]




.. GENERATED FROM PYTHON SOURCE LINES 231-235

Both ``update_all`` and the functions in ``nn.functional`` namespace
support MFGs, so you can migrate the code working for small
graphs to large graph training with minimal changes introduced above.


.. GENERATED FROM PYTHON SOURCE LINES 238-247

Writing GNN Modules for Both Full-graph Training and Stochastic Training
------------------------------------------------------------------------

Here is a step-by-step tutorial for writing a GNN module for both
:doc:`full-graph training <../blitz/1_introduction>` *and* :doc:`stochastic
training <L1_large_node_classification>`.

Say you start with a GNN module that works for full-graph training only:


.. GENERATED FROM PYTHON SOURCE LINES 247-287

.. code-block:: Python



    class SAGEConv(nn.Module):
        """Graph convolution module used by the GraphSAGE model.

        Parameters
        ----------
        in_feat : int
            Input feature size.
        out_feat : int
            Output feature size.
        """

        def __init__(self, in_feat, out_feat):
            super().__init__()
            # A linear submodule for projecting the input and neighbor feature to the output.
            self.linear = nn.Linear(in_feat * 2, out_feat)

        def forward(self, g, h):
            """Forward computation

            Parameters
            ----------
            g : Graph
                The input graph.
            h : Tensor
                The input node feature.
            """
            with g.local_scope():
                g.ndata["h"] = h
                # update_all is a message passing API.
                g.update_all(
                    message_func=fn.copy_u("h", "m"),
                    reduce_func=fn.mean("m", "h_N"),
                )
                h_N = g.ndata["h_N"]
                h_total = torch.cat([h, h_N], dim=1)
                return self.linear(h_total)









.. GENERATED FROM PYTHON SOURCE LINES 288-366

**First step**: Check whether the input feature is a single tensor or a
pair of tensors:

.. code:: python

   if isinstance(h, tuple):
       h_src, h_dst = h
   else:
       h_src = h_dst = h

**Second step**: Replace node features ``h`` with ``h_src`` or
``h_dst``, and assign the node features to ``srcdata`` or ``dstdata``,
instead of ``ndata``.

Whether to assign to ``srcdata`` or ``dstdata`` depends on whether the
said feature acts as the features on source nodes or destination nodes
of the edges in the message functions (in ``update_all`` or
``apply_edges``).

*Example 1*: For the following ``update_all`` statement:

.. code:: python

   g.ndata['h'] = h
   g.update_all(message_func=fn.copy_u('h', 'm'), reduce_func=fn.mean('m', 'h_N'))

The node feature ``h`` acts as source node feature because ``'h'``
appeared as source node feature. So you will need to replace ``h`` with
source feature ``h_src`` and assign to ``srcdata`` for the version that
works with both cases:

.. code:: python

   g.srcdata['h'] = h_src
   g.update_all(message_func=fn.copy_u('h', 'm'), reduce_func=fn.mean('m', 'h_N'))

*Example 2*: For the following ``apply_edges`` statement:

.. code:: python

   g.ndata['h'] = h
   g.apply_edges(fn.u_dot_v('h', 'h', 'score'))

The node feature ``h`` acts as both source node feature and destination
node feature. So you will assign ``h_src`` to ``srcdata`` and ``h_dst``
to ``dstdata``:

.. code:: python

   g.srcdata['h'] = h_src
   g.dstdata['h'] = h_dst
   # The first 'h' corresponds to source feature (u) while the second 'h' corresponds to destination feature (v).
   g.apply_edges(fn.u_dot_v('h', 'h', 'score'))

.. note::

   For homogeneous graphs (i.e. graphs with only one node type
   and one edge type), ``srcdata`` and ``dstdata`` are aliases of
   ``ndata``. So you can safely replace ``ndata`` with ``srcdata`` and
   ``dstdata`` even for full-graph training.

**Third step**: Replace the ``ndata`` for outputs with ``dstdata``.

For example, the following code

.. code:: python

   # Assume that update_all() function has been called with output node features in `h_N`.
   h_N = g.ndata['h_N']
   h_total = torch.cat([h, h_N], dim=1)

will change to

.. code:: python

   h_N = g.dstdata['h_N']
   h_total = torch.cat([h_dst, h_N], dim=1)


.. GENERATED FROM PYTHON SOURCE LINES 369-372

Putting together, you will change the ``SAGEConvForBoth`` module above
to something like the following:


.. GENERATED FROM PYTHON SOURCE LINES 372-419

.. code-block:: Python



    class SAGEConvForBoth(nn.Module):
        """Graph convolution module used by the GraphSAGE model.

        Parameters
        ----------
        in_feat : int
            Input feature size.
        out_feat : int
            Output feature size.
        """

        def __init__(self, in_feat, out_feat):
            super().__init__()
            # A linear submodule for projecting the input and neighbor feature to the output.
            self.linear = nn.Linear(in_feat * 2, out_feat)

        def forward(self, g, h):
            """Forward computation

            Parameters
            ----------
            g : Graph
                The input graph.
            h : Tensor or tuple[Tensor, Tensor]
                The input node feature.
            """
            with g.local_scope():
                if isinstance(h, tuple):
                    h_src, h_dst = h
                else:
                    h_src = h_dst = h

                g.srcdata["h"] = h_src
                # update_all is a message passing API.
                g.update_all(
                    message_func=fn.copy_u("h", "m"),
                    reduce_func=fn.mean("m", "h_N"),
                )
                h_N = g.ndata["h_N"]
                h_total = torch.cat([h_dst, h_N], dim=1)
                return self.linear(h_total)


    # Thumbnail credits: Representation Learning on Networks, Jure Leskovec, WWW 2018
    # sphinx_gallery_thumbnail_path = '_static/blitz_3_message_passing.png'








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 24.800 seconds)


.. _sphx_glr_download_tutorials_large_L4_message_passing.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: L4_message_passing.ipynb <L4_message_passing.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: L4_message_passing.py <L4_message_passing.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: L4_message_passing.zip <L4_message_passing.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
